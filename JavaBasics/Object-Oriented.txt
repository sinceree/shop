面向对象三大特征：封装、继承和多态

类和对象的区别：
1.对象是具体的事物，类是对对象的抽象
2.类是看成一类对象的模板，对象可以看成是该类的具体实例
3.类是描述同一类型对象的一个抽象概念，类定义了这一类对象所对应具有的共同属性和方法

类的定义：一般具有三个成员，属性(成员变量)、方法和构造器
修饰符 class 类名 {
}

构造器：用于对象的初始化
修饰符 类名(形参){
}
1.通过new关键字调用
2.不能定义返回值类型，不能使用return返回某个值
3.我们没有定义构造器，系统会默认给生成一个构造器
4.构造器名必须要和类名一致

构造方法的重载：其定义与方法的重载一致
1.方法构造中形参名和属性名相同时，需要使用this关键字区分
2.this.id表示成员变量，id表示形参id
3.this不能用于static方法中

static关键字：
1.static声明的成员变量为静态成员变量，与类的生命周期一致
2.一般用“类名.类属性/方法”来调用
3.在static方法中不可直接访问非static的成员
4.static修饰的方法和成员变量从属于类；普通变量和方法从属于对象

静态初始化块：用于类的初始化，在静态初始化块中不能直接访问非static成员
静态初始化块执行顺序：上溯到Object类，先执行Object的静态初始化块，再向下执行子类的静态初始化块，直到我们的类的静态初始化块为止。

参数的传递：
1.基本数据类型传递的是数据的副本，副本改变不会影响原件
2.引用数据类型传递的是对象的地址，改变副本指向地址对象的值，意味着原参数指向对象的值也发生了改变

JDK中主要的包：
java.lang	包含一些Java语言的核心类，如String、Math、Integer、System和Thread，提供常用功能。
java.awt	包含了构成抽象窗口工具集（abstract window toolkits）的多个类，这些类被用来构建和管理应用程序的图形用户界面(GUI)。
java.net	包含执行与网络相关的操作的类。
java.io	包含能提供多种输入/输出功能的类。
java.util	包含一些实用工具类，如定义系统特性、使用与日期日历相关的函数。

继承：使用extends关键字继承
修饰符 class 子类名 extends 父类名{
}
要点：
1.Java类只有单继承，没有多继承；接口有多继承
2.子类继承父类，可以获得全部的属性和方法(除父类的构造方法)，但私有属性和方法不能直接使用
3.所有类的父类是：java.lang.Object

instanceof运算符：当左边对象是右面类或子类所创建对象时，返回true；否则，返回false

方法的重写override：
1.方法名、形参列表相同
2.返回值类型和声明异常类型，子类小于等于父类
3.访问权限，子类大于等于父类

==方法：如果是基本类型则表示值相等，如果是引用类型则表示地址相等即是同一个对象
equals方法：默认比较的是两个对象的hashcode，是同一对象的引用返回 true 否则返回 false

super关键字：是直接父类对象的引用。可以通过super来访问父类中被子类覆盖的方法或属性

封装的优点：
1.提高代码的安全性
2.提高代码的复用性
3.高内聚、低耦合

封装的实现：使用访问控制符
1. private 表示私有，只有自己类能访问
2. default表示没有修饰符修饰，只有同一个包的类能访问
3. protected表示可以被同一个包的类以及其他包中的子类访问
4. public表示可以被该项目的所有包中的所有类访问

多态：
1. 多态是方法的多态，不是属性的多态(多态与属性无关)。
2. 多态的存在要有3个必要条件：继承，方法重写，父类引用指向子类对象。
3. 父类引用指向子类对象后，用该父类引用调用子类重写的方法，此时多态就出现了

final关键字：
1.修饰变量：变量不可改变
2.修饰方法：方法不能被子类重写
3.修饰类：类不能被继承

抽象类：使用abstract关键字修饰
1.有抽象方法的类只能定义成抽象类
2.抽象类不能实例化，即不能用new来实例化抽象类
3.抽象类可以包含属性、方法、构造方法。但是构造方法不能用来new实例，只能用来被子类调用
4.抽象类只能用来被继承
5.抽象方法必须被子类实现

接口：
访问修饰符 interface 接口名 [extends 接口1,接口2]{
常量定义
方法定义
}
注意：
1.访问修饰符只能是public或默认
2.接口中的属性只能是常量
3.接口中的方法只能是抽象方法(public abstract)
要点：
1. 子类通过implements来实现接口中的规范。
2. 接口不能创建实例，但是可用于声明引用变量类型。
3. 一个类实现了接口，必须实现接口中所有的方法，并且这些方法只能是public的。
4. JDK1.7之前，接口中只能包含静态常量、抽象方法，不能有普通属性、构造方法、普通方法。
5. JDK1.8后，接口中包含普通的静态方法。

内部类：类中类
作用：
1.提供了更好的封装
2.内部类可以直接访问外部类的私有属性，内部类被当成其外部类的成员。 但外部类不能访问内部类的内部属性
3.内部类使得多重继承的解决方案变得更加完整

匿名内部类：
new 父类构造器(实参类表) 实现接口(){
}